/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
package QueryParser;

import java.io.*;
import java.util.*;

// import Berkeley DB
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

public class SimpleDBMSParser implements SimpleDBMSParserConstants {

  public static final int ERROR_FLAG = -1;
  // ENUM FOR PRINT_VALUE
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SHOW_TABLES = 4;
  public static final int PRINT_SELECT = 5;
  public static final int PRINT_INSERT = 6;
  public static final int PRINT_DELETE = 7;

  // ENUM FOR PRJ1-2 MESSAGES
  public static final int SyntaxError = 8;
  public static final int CreateTableSuccess = 9;
  public static final int DuplicateColumnDefError = 10;
  public static final int DuplicatePrimaryKeyDefError = 11;
  public static final int ReferenceTypeError = 12;
  public static final int ReferenceNonPrimaryKeyError = 13;
  public static final int ReferenceColumnExistenceError = 14;
  public static final int ReferenceTableExistenceError = 15;
  public static final int NonExistingColumnDefError = 16;
  public static final int TableExistenceError = 17;
  public static final int DropSuccess = 18;
  public static final int DropReferencedTableError = 19;
  public static final int ShowTablesNoTable = 20;
  public static final int NoSuchTable = 21;
  public static final int CharLengthError = 22;
  public static final int DuplicateForeignKeyDefError = 23;
  public static final int ReferencedByMyself = 24;



  public static void main(String args[]) throws ParseException
  {
    /* Project 1-2 */

        // Environment & Database define
    Environment myDbEnvironment = null;
    Database FK_DB_myDatabase = null;

        /* OPENING DB */

        // Open Database Environment or if not, create one.
        EnvironmentConfig envConfig = new EnvironmentConfig();
        envConfig.setAllowCreate(true);
        myDbEnvironment = new Environment(new File("db/"), envConfig);

        // Open Database or if not, create one.
        DatabaseConfig dbConfig = new DatabaseConfig();
        dbConfig.setAllowCreate(true);
        dbConfig.setSortedDuplicates(true);
        FK_DB_myDatabase = myDbEnvironment.openDatabase(null, "FK_DB", dbConfig);
        // This is FK_DB for store (referencing table, referenced table)

        if(FK_DB_myDatabase != null) {
          FK_DB_myDatabase.close();
        }


        //Cursor cursor = null;
        /* < key, value > DB에 넣기 */
/*
	DatabaseEntry key;
	DatabaseEntry data;

	try {
		cursor = myDatabase.openCursor(null, null);
		key = new DatabaseEntry("key_d".getBytes("UTF-8"));
		data = new DatabaseEntry("value_d2".getBytes("UTF-8"));
		cursor.put(key,data);
	} catch (DatabaseException de) {
	  
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}
*/
        /* < key, value > 찾아서 가져오기 */
/*
	DatabaseEntry foundKey = new DatabaseEntry();
	DatabaseEntry foundData = new DatabaseEntry();
	try {
		cursor = myDatabase.openCursor(null, null);
	} catch (Exception e) {

	}
	cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
	if(foundKey.getData() != null) { 
		do {
			try {
				String keyString = new String(foundKey.getData(), "UTF-8");
				String dataString = new String(foundData.getData(), "UTF-8");
				System.out.println(keyString);
				System.out.println(dataString);
			} catch (DatabaseException de) {
			  
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
	
		} while ( cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS );
	}
*/

        /*Close DB 
	if(myDatabase != null) {
	  cursor.close();
	  myDatabase.close();
	}
	
	if(myDbEnvironment != null) myDbEnvironment.close();
    */



        /* Project 1-1 */
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2016-12299> ");

    while (true)
    {
      try
      {
        parser.command(myDbEnvironment); // command 실행
      }
      catch (Exception e)
      {
        ArrayList q = new ArrayList();
        q.add(PRINT_SYNTAX_ERROR);
        printMessage(q, null);

        SimpleDBMSParser.ReInit(System.in);
      }
    }

  }

  public static void printMessage(ArrayList q, Environment myDbEnvironment)
  {
    DatabaseConfig dbConfig = new DatabaseConfig();

    int i;
    int j;
    int size;
    int flag = 0;
    List myDbNames;
    TablePlusContents tpc = new TablePlusContents();    // table이름과 그 쿼리내용이 담긴 class
    ArrayList all_contents = new ArrayList();  // 쿼리 하나의 전체 내용
    ArrayList sub_contents = new ArrayList();  // 쿼리 parsing
    ArrayList column_list = new ArrayList();  // 쿼리의 main table의 모든 column의 내용
    ArrayList fk_list = new ArrayList();  // fk와 관련된 모든 정보 parsing

    ArrayList<String> column_name_list = new ArrayList<String>(); // column_list에서 이름만 뽑은 것
    ArrayList<String> pk_columns = new ArrayList<String>(); // fk_list에서 column정보만 뺀것
        ArrayList<String> fk_referencing_columns = new ArrayList<String>();
        ArrayList<String> fk_referenced_tables = new ArrayList<String>();


    switch((int)q.get(0))
    {
      case PRINT_SYNTAX_ERROR:
        printErrorMessage(SyntaxError);
        break;
      case PRINT_CREATE_TABLE:
        // 인자 얻기
        tpc = (TablePlusContents)q.get(1); // 쿼리 내용 얻기
        String table_name = tpc.getTableName().toLowerCase();   // 테이블 이름 얻고 소문자로 변경
        all_contents = tpc.getContents();

        //System.out.println( all_contents );

                // 시작
                myDbNames = myDbEnvironment.getDatabaseNames();
                size = myDbNames.size();
                for(i=0; i < size; i++) {
                        String temp = (String)myDbNames.get(i);
                        if(temp.equals(table_name)) break;      // 같은 이름의 table이 이미 있으면 break
                }
            if(i == size) { // 같은 이름의 table 없음
                int temp_counter = 0; // primary 중복 체크용 counter

                        // 우선 쿼리를 column, pk, fk로 나누기 위한 for문
                        for(j=0; j < all_contents.size(); j++) {  // 모든 contents를 하나씩 검사
                                sub_contents = (ArrayList)all_contents.get(j);  // 한줄 한줄씩 parsing

                                if( !(sub_contents.get(0)).equals("primary key") && !(sub_contents.get(0)).equals("foreign key")) {  // 1. column
                                        for(String column_name : column_name_list){
                                            if(column_name.equals(sub_contents.get(0))) {  // column에 중복 발견
                                                        printErrorMessage(DuplicateColumnDefError);  // ERROR: DuplicateColumnDefError
                                                        flag = ERROR_FLAG;
                                                        break;
                                            }
                                        }
                                        if (flag == ERROR_FLAG) break;
                                        // charLengthError 검출
                                        if(((String)sub_contents.get(1)).contains("char")) {
                                                String temp_char = ((String)sub_contents.get(1)).substring(5,((String)sub_contents.get(1)).length()-1);
                                                if(Integer.parseInt(temp_char) < 1) {   // char의 int가 1보다 작을 경우
                                                    printErrorMessage(CharLengthError); // ERROR: CharLengthError
                                                        flag = ERROR_FLAG;
                                                        break;
                                                }
                                        }
                                        if (flag == ERROR_FLAG) break;

                                        // column 통과
                                        column_list.add(sub_contents); // column list에 추가
                                        column_name_list.add((String)sub_contents.get(0)); // column name list에 추가

                                } else if ((sub_contents.get(0)).equals("primary key")) {  // 2. primary key
                                        temp_counter++;
                                        if(temp_counter > 1) {  // primary key가 두 개 이상일 때
                                                printErrorMessage(DuplicatePrimaryKeyDefError); // ERROR: DuplicatePrimaryKeyDefError
                                                flag = ERROR_FLAG;
                                                break;
                                        } else {
                                                pk_columns = (ArrayList)sub_contents.get(1);    // pk_column에 추가
                                        }
                                } else if ((sub_contents.get(0)).equals("foreign key")) {  // 3. foreign key
                                        fk_list.add(sub_contents);  // fk_list에 추가
                                }
                        }
                        if (flag == ERROR_FLAG) break; // error가 있었다면 query 종료

                        //System.out.println("column :" + column_list);
                        //System.out.println("pk: " + pk_columns);

                        // primary key 처리
                        for(String column_name : pk_columns) {  // pk_column에 해당하는 column이 존재하지 않는 경우 error
                                if( !column_name_list.contains(column_name) ) {
                                        printErrorMessage(NonExistingColumnDefError, column_name);      // ERROR: NonExistingColumnDefError
                                        flag = ERROR_FLAG;
                                        break;
                                }
                        }
                        if (flag == ERROR_FLAG) break;


                        Database ref_myDatabase = null;
                        Cursor fk_cursor = null;
                        // foreign key 처리   // ★ 훨씬 더 최적화할 수 있을텐데 아쉽다
                        for(j=0; j < fk_list.size(); j++) {
                                ArrayList sub_fk = (ArrayList)fk_list.get(j);  // fk_list를 하나씩 꺼내서 돌리기
                                ArrayList<String> fk_columns = (ArrayList)sub_fk.get(1);  // 참조하는 columns
                                String referenced_table_name = (String)sub_fk.get(2); // 참조되는 table
                                ArrayList<String> referenced_columns = (ArrayList)sub_fk.get(3);  // 참조되는 columns

                                // error: 같은 테이블을 참조할 경우
                                if(table_name.equals(referenced_table_name)) {
                                        printErrorMessage(ReferencedByMyself);   // ERROR: ReferencedByMyself
                                        flag = ERROR_FLAG;
                                        break;
                                }

                                // error: 없는 column일 경우
                                for(String column_name : fk_columns) {
                                        if( !(column_name_list.contains(column_name)) ) {
                                                printErrorMessage(NonExistingColumnDefError, column_name);  // ERROR: NonExistingColumnDefError
                                                flag = ERROR_FLAG;
                                                break;
                                        }
                                }
                                if (flag == ERROR_FLAG) break;

                                // error: 개수가 다를 경우
                                if(fk_columns.size() != referenced_columns.size()) {
                                        printErrorMessage(ReferenceTypeError);  // ERROR: ReferenceTypeError
                                        flag = ERROR_FLAG;
                                        break;
                                }

                                // 참조하는 table 열기
                                ref_myDatabase = null;
                                try {
                                        dbConfig.setAllowCreate(false); // table이 없으면 error 처리하기 위함
                                        dbConfig.setSortedDuplicates(true);
                                        ref_myDatabase = myDbEnvironment.openDatabase(null, referenced_table_name, dbConfig);
                                } catch (Exception e) {
                                        printErrorMessage(ReferenceTableExistenceError);  // ERROR: ReferenceTableExistenceError
                                        flag = ERROR_FLAG;
                                        break;
                                }
                                /* < key, value > 찾아서 가져오기 */
                                DatabaseEntry foundKey = new DatabaseEntry();
                                DatabaseEntry foundData = new DatabaseEntry();
                                ArrayList<String> key_array = new ArrayList();
                                ArrayList<String> data_array = new ArrayList();
                                fk_cursor = null;
                                try {
                                        fk_cursor = ref_myDatabase.openCursor(null, null);
                                } catch (Exception e) {
                                        System.out.println("cursor open error");
                                        break;
                                }
                                fk_cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
                                if(foundKey.getData() != null) {
                                        do {
                                                try {
                                                        String keyString = new String(foundKey.getData(), "UTF-8");
                                                        String dataString = new String(foundData.getData(), "UTF-8");

                                                        key_array.add(keyString);  // 참조하는 테이블의 KEY
                                                        data_array.add(dataString);  // 참조하는 테이블의 DATA
                                                } catch (Exception e) {
                                                    System.out.println("cursor error");
                                                }
                                        } while ( fk_cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS );
                                }

                                // error: 없는 column을 참조할 경우, primary key가 아닌 것을 참조할 경우
                                for(String ref_column_name : referenced_columns) {
                                        if( !(key_array.contains(ref_column_name+":column_name")) ) {  // error: 없는 column을 참조할 경우
                                                printErrorMessage(ReferenceColumnExistenceError);  // ERROR: ReferenceColumnExistenceError
                                                flag = ERROR_FLAG;
                                                break;
                                        }
                                        if( !(key_array.contains(ref_column_name+":primary_key")) ) {  // error: primary key가 아닌 것을 참조할 경우
                                                printErrorMessage(ReferenceNonPrimaryKeyError);  // ERROR: ReferenceNonPrimaryKeyError
                                                flag = ERROR_FLAG;
                                                break;
                                        }
                                }
                                if (flag == ERROR_FLAG) break;


                                // + error: composite primary key 중 일부만 참조할 경우
                                int pk_count = 0; // primary key의 개수를 세는 count
                                for(String key_each: key_array) {
                                        if(key_each.contains(":primary_key")) pk_count++;
                                }
                                if(pk_count != fk_columns.size()) {  // primary key의 수와 다를 경우
                                        printErrorMessage(ReferenceNonPrimaryKeyError);  // ERROR: ReferenceNonPrimaryKeyError
                                        flag = ERROR_FLAG;
                                        break;
                                }

                                if (flag == ERROR_FLAG) break;

                                // error: 타입이 다를 경우
                                for(int k=0; k < fk_columns.size(); k++) {
                                        int index; int index2;
                                        if( (index = key_array.indexOf(referenced_columns.get(k)+":type")) != -1 ) {
                                                if( (index2 = column_name_list.indexOf(fk_columns.get(k))) != -1 ) {
                                                  //System.out.println(data_array.get(index));
                                                  //System.out.println(((ArrayList)column_list.get(index2)).get(1));
                                                  if( !( (data_array.get(index)).equals(((ArrayList)column_list.get(index2)).get(1)) ) ) {   // 다를 경우
                                                                printErrorMessage(ReferenceTypeError);  // ERROR: ReferenceTypeError
                                                                flag = ERROR_FLAG;
                                                                break;
                                                  }
                                                } else System.out.println("column non exist error");
                                        } else System.out.println("type non exist error");
                                }

                                if (flag == ERROR_FLAG) break;

                                // 여기까지 error 없으면  fk_referencing_columns, referenced_tables에 저장
                                for(String column_name : fk_columns) {
                                        if( fk_referencing_columns.contains(column_name)) {  // 같은 column을 여러 번 foreign key로 정의할 경우
                                                printErrorMessage(DuplicateForeignKeyDefError);  // ERROR: DuplicateForeignKeyDefError
                                                flag = ERROR_FLAG;
                                                break;
                                        } else {
                                                fk_referencing_columns.add(column_name);
                                                fk_referenced_tables.add(referenced_table_name);  // bug 가능성 - 중복 값 들어감
                                        }
                                }
                                if (flag == ERROR_FLAG) break;

                                // 참조하는 table 닫기
                                if(ref_myDatabase != null) {
                                  fk_cursor.close();
                                  ref_myDatabase.close();
                                }
                        }
                        // 참조하는 table 닫기  
                        if(ref_myDatabase != null) {
                          fk_cursor.close();
                          ref_myDatabase.close();
                        }
                        if (flag == ERROR_FLAG) break;


                        // table 만들기 시작
                        dbConfig.setAllowCreate(true);
                        dbConfig.setSortedDuplicates(true);
                        Database myDatabase = myDbEnvironment.openDatabase(null, table_name, dbConfig);
                        Cursor cursor = null;

                        /* < key, value > DB에 넣기 */
                        DatabaseEntry key;
                        DatabaseEntry data;
                        try {
                                cursor = myDatabase.openCursor(null, null);
                                // 1. column
                                for(j=0; j < column_list.size(); j++) {
                                        ArrayList<String> each_column = new ArrayList<String>();
                                        each_column = (ArrayList<String>)column_list.get(j);

                                        // column order
                                        key = new DatabaseEntry((each_column.get(0)+":order").getBytes("UTF-8"));
                                        data = new DatabaseEntry(String.valueOf(j).getBytes("UTF-8"));
                                        cursor.put(key,data);
                                        // column 이름
                                        key = new DatabaseEntry((each_column.get(0)+":column_name").getBytes("UTF-8"));
                                        data = new DatabaseEntry(each_column.get(0).getBytes("UTF-8"));
                                        cursor.put(key,data);
                                        // column type
                                        key = new DatabaseEntry((each_column.get(0)+":type").getBytes("UTF-8"));
                                        data = new DatabaseEntry(each_column.get(1).getBytes("UTF-8"));
                                        cursor.put(key,data);
                                        // column not_null
                                        if(each_column.get(2).equals("not null")) {
                                                key = new DatabaseEntry((each_column.get(0)+":not_null").getBytes("UTF-8"));
                                                data = new DatabaseEntry("Y".getBytes("UTF-8"));
                                                cursor.put(key,data);
                                        }
                                        // 그 column이 pk일 경우
                                        if(pk_columns.contains(each_column.get(0))) {
                                                // column primary key
                                                key = new DatabaseEntry((each_column.get(0)+":primary_key").getBytes("UTF-8"));
                                                data = new DatabaseEntry("Y".getBytes("UTF-8"));
                                                cursor.put(key,data);
                                                // column not null
                                                key = new DatabaseEntry((each_column.get(0)+":not_null").getBytes("UTF-8"));
                                                data = new DatabaseEntry("Y".getBytes("UTF-8"));
                                                cursor.put(key,data);
                                        }
                                        // 그 column이 fk일 경우
                                        if(fk_referencing_columns.contains(each_column.get(0))) {
                                                // column foreign key
                                                key = new DatabaseEntry((each_column.get(0)+":foreign_key").getBytes("UTF-8"));
                                                data = new DatabaseEntry("Y".getBytes("UTF-8"));
                                                cursor.put(key,data);
                                        }
                                        //
                                        // (나중에 column_name:referencing_table, column 추가하기)
                                        //
                                }

                        } catch (Exception e) {
                                System.out.println(e);
                                flag = ERROR_FLAG;
                        }

                        /* Close DB */
                        if(myDatabase != null) {
                          cursor.close();
                          myDatabase.close();
                        }
                        if(flag == ERROR_FLAG) break;


                        /*****************/
                        // FK_DB에 referencing_table, referenced_table를 key, value로 저장
                        dbConfig.setAllowCreate(false);
                        Database fk_myDatabase = myDbEnvironment.openDatabase(null, "FK_DB", dbConfig);
                        Cursor fk_cursor2 = null;
                        /* < key, value > DB에 넣기 */
                        DatabaseEntry fk_key;
                        DatabaseEntry fk_data;

                        try {
                                fk_cursor2 = fk_myDatabase.openCursor(null, null);
                                for(String fk_referenced_table : fk_referenced_tables) {
                                        fk_key = new DatabaseEntry(table_name.getBytes("UTF-8"));       // 참조하는 테이블
                                        fk_data = new DatabaseEntry(fk_referenced_table.getBytes("UTF-8"));     // 참조되는 테이블
                                        fk_cursor2.put(fk_key,fk_data);
                                }
                        } catch (Exception e) {
                                System.out.println("cursor error");
                        }

                        if(fk_myDatabase != null) {
                          fk_cursor2.close();
                          fk_myDatabase.close();
                        }
                        /******************/

                        printSuccessMessage(CreateTableSuccess, table_name);  // SUCCESS: CreateTableSuccess

                } else if (i < size) { // 이미 같은 이름의 table이 존재
                printErrorMessage(TableExistenceError);  // ERROR: TableExistenceError
                break;
                }
        break;
      case PRINT_DROP_TABLE:
                dbConfig.setAllowCreate(false); // table이 없으면 error 처리하기 위함
                dbConfig.setSortedDuplicates(true);
                Database drop_myDatabase = null;
                String drop_dbName = new String();
                try {
                        drop_myDatabase = myDbEnvironment.openDatabase(null, ((String)q.get(1)).toLowerCase(), dbConfig); // case insensitive
                        drop_dbName = drop_myDatabase.getDatabaseName();  // 테이블 이름 저장
                }  catch (Exception e) {
                        printErrorMessage(NoSuchTable); // ERROR: NoSuchTable
                        flag = ERROR_FLAG;
                }
                if(drop_myDatabase != null) {
                        drop_myDatabase.close();
                }
                if(flag == ERROR_FLAG) break;

                Database drop_fk_myDatabase = myDbEnvironment.openDatabase(null, "FK_DB", dbConfig); // FK_DB 열기
                Cursor drop_fk_cursor = null;

                DatabaseEntry fk_foundKey = new DatabaseEntry();
                DatabaseEntry fk_foundData = new DatabaseEntry();
                try {
                        drop_fk_cursor = drop_fk_myDatabase.openCursor(null, null);
                } catch (Exception e) {
                        System.out.println("fk cursor error");
                }

                drop_fk_cursor.getFirst(fk_foundKey, fk_foundData, LockMode.DEFAULT);
                if(fk_foundKey.getData() != null) {
                        do {
                                try {
                                        String dataString = new String(fk_foundData.getData(), "UTF-8");  // data = referenced table
                                        if(dataString.equals(drop_dbName)) {  // 다른 데에서 참조되고 있는 테이블일 경우
                                                flag = ERROR_FLAG;
                                                break;
                                        }
                                } catch (Exception e) {
                                    e.printStackTrace();
                                    flag = ERROR_FLAG;
                                }

                        } while ( drop_fk_cursor.getNext(fk_foundKey, fk_foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS );
                }
                if(flag == ERROR_FLAG) {
                        printErrorMessage(DropReferencedTableError, drop_dbName);  // ERROR: DropReferencedTableError
                        drop_fk_cursor.close();
                        drop_fk_myDatabase.close();
                        break;
                }
                // 통과

                Cursor drop_fk_cursor2 = null;
                try {
                        drop_fk_cursor2 = drop_fk_myDatabase.openCursor(null, null);
                } catch (Exception e) {
                        System.out.println("fk cursor2 error");
                }
                // 참조하고 있었던 정보 지우기
                drop_fk_cursor2.getFirst(fk_foundKey, fk_foundData, LockMode.DEFAULT);
                if(fk_foundKey.getData() != null) {
                        do {
                                try {
                                        String keyString = new String(fk_foundKey.getData(), "UTF-8");  // key = referencing table
                                        if(keyString.equals(drop_dbName)) {  // 다른 곳을 참조하고 있었을 경우
                                                drop_fk_cursor2.delete();  // 해당 정보 삭제
                                        }
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }

                        } while ( drop_fk_cursor2.getNext(fk_foundKey, fk_foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS );
                }

                if(drop_fk_myDatabase != null) {
                  drop_fk_cursor.close();
                  drop_fk_cursor2.close();
                  drop_fk_myDatabase.close();
                }

                myDbEnvironment.removeDatabase(null, drop_dbName);      // table drop
                printSuccessMessage(DropSuccess, drop_dbName);  // SUCCESS: DropSuccess

        break;
      case PRINT_DESC:
        dbConfig.setAllowCreate(false); // table이 없으면 error 처리하기 위함
                dbConfig.setSortedDuplicates(true);
                Database desc_myDatabase = null;
                String desc_dbName = new String();  // 해당 table name
                try {
                        desc_myDatabase = myDbEnvironment.openDatabase(null, ((String)q.get(1)).toLowerCase(), dbConfig); // case insensitive .toLowerCase()
                        desc_dbName = desc_myDatabase.getDatabaseName();  // table 이름 저장
                        Cursor desc_cursor = null;

                        ArrayList<String> key_array = new ArrayList<String>();  // 모든 키 저장
                        ArrayList<String> data_array = new ArrayList<String>();  // 모든 data 저장
                        ArrayList<String> column_array = new ArrayList<String>();  // column이름만 저장
                        ArrayList<String> order_array = new ArrayList<String>();  // 순서 저장
                        /* < key, value > 찾아서 가져오기 */
                        // 정보 저장하기
                        DatabaseEntry foundKey = new DatabaseEntry();
                        DatabaseEntry foundData = new DatabaseEntry();
                        try {
                                desc_cursor = desc_myDatabase.openCursor(null, null);
                        } catch (Exception e) {
                                System.out.println("cursor open error");
                        }
                        desc_cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
                        if(foundKey.getData() != null) {
                                do {
                                        try {
                                                String keyString = new String(foundKey.getData(), "UTF-8");
                                                String dataString = new String(foundData.getData(), "UTF-8");

                                                if(keyString.contains(":column_name")) column_array.add(dataString);
                                                if(keyString.contains(":order")) order_array.add(dataString);
                                                key_array.add(keyString);
                                                data_array.add(dataString);
                                        } catch (Exception e) {
                                                System.out.println("cursor error");
                                        }

                                } while ( desc_cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS );
                        }
                        //System.out.println(column_array);
                        //System.out.println(key_array);
                        //System.out.println(data_array);
                        //System.out.println(order_array);

                        // desc 출력
                        System.out.println("-----------------------------------------");
                        System.out.println("table_name [" + desc_dbName + "]");
                        System.out.println("column_name"+"       "+"type"+"        "+"null"+"        "+"key");

                        for(i=0; i < column_array.size(); i++) {
                                int index = 0;
                                String order = order_array.get(i);
                                // order를 i번째꺼를 찾고, 그걸 column_Arry.get 의 인자로 넘긴다!!!
                                String column_name = column_array.get(Integer.parseInt(order));

                                // 기본 정보 출력
                                if( (index = key_array.indexOf(column_name+":column_name")) != -1 )  System.out.print(data_array.get(index)+"          ");
                                if( (index = key_array.indexOf(column_name+":type")) != -1 )  System.out.print(data_array.get(index)+"          ");
                                 if( (index = key_array.indexOf(column_name+":not_null")) != -1 )  System.out.print("N          ");
                                 else  System.out.print("Y           ");

                                // pk&fk 출력
                                boolean pk_index = ((key_array.indexOf(column_name+":primary_key")) != -1);
                                boolean fk_index = ((key_array.indexOf(column_name+":foreign_key")) != -1);
                                if( pk_index && fk_index )  System.out.print("PRI/FOR");
                                else if ( pk_index && !fk_index) System.out.print("PRI");
                                else if ( !pk_index && fk_index) System.out.print("FOR");

                                System.out.println();
                        }

                        System.out.println("-----------------------------------------");

                        /* Close DB */
                        if(desc_myDatabase != null) {
                          desc_cursor.close();
                          desc_myDatabase.close();
                        }

                } catch (Exception e) {
                        printErrorMessage(NoSuchTable);  // ERROR: NoSuchTable
                }
        break;

      case PRINT_SHOW_TABLES:
            myDbNames = myDbEnvironment.getDatabaseNames();
            size = myDbNames.size();
            if(size > 1) {  // FK_DB를 제외하고 TABLE이 없을 때
                System.out.println("----------------");
                        for(i=0; i < size; i++) {
                          if(!((String)myDbNames.get(i)).equals("FK_DB"))
                                System.out.println((String)(myDbNames.get(i)));  // 하나씩 출력
                        }
                        System.out.println("----------------");
                } else {
                printErrorMessage(ShowTablesNoTable);  // ERROR: ShowTablesNoTable
                }
        break;
      case PRINT_SELECT:
        System.out.println("\u005c'SELECT\u005c' requested");
        break;
      case PRINT_INSERT:
        System.out.println("\u005c'INSERT\u005c' requested");
        break;
      case PRINT_DELETE:
        System.out.println("\u005c'DELETE\u005c' requested");
        break;
    }
    System.out.print("DB_2016-12299> ");




  }

  public static void printErrorMessage(int Em)
  {
    switch(Em)
    {
        case SyntaxError:
                System.out.println("Syntax error");
                        break;
                case DuplicateColumnDefError:
                        System.out.println("Create table has failed: column definition is duplicated");
                        break;
                case DuplicatePrimaryKeyDefError:
                        System.out.println("Create table has failed: primary key definition is duplicated");
                        break;
                case ReferenceTypeError:
                        System.out.println("Create table has failed: foreign key references wrong type");
                        break;
                case ReferenceNonPrimaryKeyError:
                        System.out.println("Create table has failed: foreign key references non primary key column");
                        break;
                case ReferenceColumnExistenceError:
                        System.out.println("Create table has failed: foreign key references non existing column");
                        break;
                case ReferenceTableExistenceError:
                        System.out.println("Create table has failed: foreign key references non existing table");
                        break;
                case TableExistenceError:
                        System.out.println("Create table has failed: table with the same name already exists");
                        break;
                case ShowTablesNoTable:
                        System.out.println("There is no table");
                        break;
                case NoSuchTable:
                        System.out.println("No such table");
                        break;
                case CharLengthError:
                        System.out.println("Char length should be over 0");
                        break;
                case DuplicateForeignKeyDefError:  // 추가
                        System.out.println("Create table has failed: foreign key definition is duplicated");
                        break;
                case ReferencedByMyself:  // 추가
                        System.out.println("Create table has failed: foreign key references myself");
                        break;
    }
  }

  public static void printErrorMessage(int Sm, String Name)
  {
    switch(Sm)
    {
                case NonExistingColumnDefError:
                        System.out.println("Create table has failed: '" + Name + "' does not exists in column definition");
                        break;
                case DropReferencedTableError:
                        System.out.println("Drop table has failed: '" + Name + "' is referenced by other table");
                        break;
    }
  }

  public static void printSuccessMessage(int Sm, String Tablename)
  {
    switch(Sm)
    {
        case CreateTableSuccess:
                System.out.println("'"+ Tablename +"'" + " table is created");
                        break;
                case DropSuccess:
                        System.out.println("'"+ Tablename +"'" + " table is dropped");
                        break;
    }
  }

  // 테이블 이름과 내용 PARSING용 CLASS (지금은 create table 전용)
  public static class TablePlusContents {
    private String table_name = null;
    private ArrayList contents = null;

    public TablePlusContents() {
        this.table_name = null;
        this.contents = null;
    }
    /*
    public void setValues(String table_name) {
        this.table_name = table_name;
        this.contents = null;
    }*/

    public void setValues(String table_name, ArrayList contents) {
        this.table_name = table_name;
        this.contents = contents;
    }


    public String getTableName() {
        return table_name;
    }

    public ArrayList getContents() {
        return contents;
    }
  }

// 쿼리나 종료문이 들어오는 command
  static final public void command(Environment myDbEnvironment) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
    case DROP_TABLE:
    case DESC:
    case SHOW_TABLES:
    case SELECT:
    case INSERT_INTO:
    case DELETE_FROM:
      queryList(myDbEnvironment);
      break;
    case EXIT:
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
      if(myDbEnvironment != null) myDbEnvironment.close();  // exit할 때 환경 닫아서 저장
      System.exit(0);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// query들의 list
  static final public void queryList(Environment myDbEnvironment) throws ParseException {
  ArrayList q;
    label_1:
    while (true) {
      q = query();
      jj_consume_token(SEMICOLON);
      printMessage(q, myDbEnvironment);  // 환경도 인자로 주기

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE_TABLE:
      case DROP_TABLE:
      case DESC:
      case SHOW_TABLES:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public ArrayList query() throws ParseException {
  ArrayList q = new ArrayList();  // 첫번째 인자는 index이고 두번째는 쿼리 내용
  int idx;
  String table_name = new String();
  TablePlusContents tpc = new TablePlusContents();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
      tpc = createTableQuery();
      idx = PRINT_CREATE_TABLE;
      q.add(idx);
      q.add(tpc);  // 쿼리 내용

      break;
    case DROP_TABLE:
      table_name = dropTableQuery();
      idx = PRINT_DROP_TABLE;
      q.add(idx);
      q.add(table_name);  // 테이블 이름

      break;
    case DESC:
      table_name = descQuery();
      idx = PRINT_DESC;
      q.add(idx);
      q.add(table_name);  // 테이블 이름

      break;
    case SHOW_TABLES:
      showTablesQuery();
      idx = PRINT_SHOW_TABLES;
      q.add(idx);
      break;
    case SELECT:
      selectQuery();
          idx = PRINT_SELECT;
      break;
    case INSERT_INTO:
      insertQuery();
          idx = PRINT_INSERT;
      break;
    case DELETE_FROM:
      deleteQuery();
          idx = PRINT_DELETE;
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return q;}
    throw new Error("Missing return statement in function");
  }

// create table 쿼리 시작
  static final public TablePlusContents createTableQuery() throws ParseException {
  String t = new String(); ArrayList tel = new ArrayList(); TablePlusContents tpc = new TablePlusContents();
    jj_consume_token(CREATE_TABLE);
    t = tableName();
    tel = tableElementList();
    tpc.setValues(t, tel);  // 테이블 이름과 쿼리 내용 넘기기
        {if (true) return tpc;}
    throw new Error("Missing return statement in function");
  }

// table의 element list ex > (column_one int not null, ...)
  static final public ArrayList tableElementList() throws ParseException {
  ArrayList tel = new ArrayList(); ArrayList te = new ArrayList();
    jj_consume_token(LEFT_PAREN);
    te = tableElement();
        tel.add(te);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      te = tableElement();
          tel.add(te);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return tel;}  // 쿼리 내용 넘기기

    throw new Error("Missing return statement in function");
  }

// one table element ex > column_one int not null
  static final public ArrayList tableElement() throws ParseException {
  ArrayList te = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      te = columnDefinition();
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      te = tableConstraintDefinition();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  {if (true) return te;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> columnDefinition() throws ParseException {
  ArrayList<String> cd = new ArrayList(); String column_name = new String(); String data_type = new String();
  Token not_null = new Token(); String not_null_str = new String();
    column_name = columnName();
    data_type = dataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      not_null = jj_consume_token(NOT_NULL);
      not_null_str = not_null.image.toLowerCase();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
        cd.add(column_name);
        cd.add(data_type);
        cd.add(not_null_str);
        {if (true) return cd;}
    throw new Error("Missing return statement in function");
  }

// primary key or foreign key 부분 시작
  static final public ArrayList tableConstraintDefinition() throws ParseException {
  ArrayList tcd = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      tcd = primaryKeyConstraint();
      break;
    case FOREIGN_KEY:
      tcd = referentialConstraint();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return tcd;}
    throw new Error("Missing return statement in function");
  }

// for primary key
  static final public ArrayList primaryKeyConstraint() throws ParseException {
  ArrayList pkc = new ArrayList(); Token primary_key; ArrayList<String> cnl = new ArrayList();
    primary_key = jj_consume_token(PRIMARY_KEY);
    cnl = columnNameList();
        pkc.add(primary_key.image.toLowerCase());
        pkc.add(cnl);
        {if (true) return pkc;}
    throw new Error("Missing return statement in function");
  }

// for foreign key
  static final public ArrayList referentialConstraint() throws ParseException {
  ArrayList fkc = new ArrayList(); Token foreign_key;
  ArrayList<String> cnl = new ArrayList(); ArrayList<String> cnl2 = new ArrayList(); String table_name = new String();
    foreign_key = jj_consume_token(FOREIGN_KEY);
    cnl = columnNameList();
    jj_consume_token(REFERENCES);
    table_name = tableName();
    cnl2 = columnNameList();
    fkc.add(foreign_key.image.toLowerCase());
    fkc.add(cnl);
    fkc.add(table_name); ////
    fkc.add(cnl2);
        {if (true) return fkc;}
    throw new Error("Missing return statement in function");
  }

// column 이름 나열 ex > (column_one, column_two, ...)
  static final public ArrayList<String> columnNameList() throws ParseException {
  ArrayList<String> cnl = new ArrayList(); String column_name = new String();
    jj_consume_token(LEFT_PAREN);
    column_name = columnName();
        cnl.add(column_name);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      column_name = columnName();
        cnl.add(column_name);
    }
    jj_consume_token(RIGHT_PAREN);
        {if (true) return cnl;}
    throw new Error("Missing return statement in function");
  }

// ex > int, char(20), date
  static final public String dataType() throws ParseException {
  Token data_type; Token[] size = new Token[3];
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      data_type = jj_consume_token(INT);
      break;
    case CHAR:
      data_type = jj_consume_token(CHAR);
      size[0] = jj_consume_token(LEFT_PAREN);
      size[1] = jj_consume_token(INT_VALUE);
      size[2] = jj_consume_token(RIGHT_PAREN);
      break;
    case DATE:
      data_type = jj_consume_token(DATE);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if(!(data_type.image.toLowerCase()).equals("char")) {
                {if (true) return data_type.image.toLowerCase();}
        } else {
                {if (true) return data_type.image.toLowerCase() + size[0].image + size[1].image + size[2].image;}
        }
    throw new Error("Missing return statement in function");
  }

// table 이름은 legal identifier여야 함
  static final public String tableName() throws ParseException {
  Token table_name;
    table_name = jj_consume_token(LEGAL_IDENTIFIER);
          {if (true) return table_name.image.toLowerCase();}  // case insensitive

    throw new Error("Missing return statement in function");
  }

// column 이름은 legal identifier여야 함
  static final public String columnName() throws ParseException {
  Token column_name;
    column_name = jj_consume_token(LEGAL_IDENTIFIER);
        {if (true) return column_name.image.toLowerCase();}  // case insensitive

    throw new Error("Missing return statement in function");
  }

// drop table 쿼리 시작
  static final public String dropTableQuery() throws ParseException {
  String t;
    jj_consume_token(DROP_TABLE);
    t = tableName();
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

// desc 쿼리 시작
  static final public String descQuery() throws ParseException {
  String t;
    jj_consume_token(DESC);
    t = tableName();
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

// show tables 쿼리 시작
  static final public void showTablesQuery() throws ParseException {
    jj_consume_token(SHOW_TABLES);
  }

// select 쿼리 시작
  static final public void selectQuery() throws ParseException {
    jj_consume_token(SELECT);
    selectList();
    tableExpression();
  }

// * 이거나 column들
  static final public void selectList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    case LEGAL_IDENTIFIER:
      selectColumn();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        selectColumn();
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// ex > table_name.column_name as as_name
  static final public void selectColumn() throws ParseException {
    if (jj_2_1(4)) {
      tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    columnName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      columnName();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
  }

// from where 
  static final public void tableExpression() throws ParseException {
    fromClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereClause();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
  }

// from 부분 시작
  static final public void fromClause() throws ParseException {
    jj_consume_token(FROM);
    tableReferenceList();
  }

  static final public void tableReferenceList() throws ParseException {
    referedTable();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      referedTable();
    }
  }

  static final public void referedTable() throws ParseException {
    tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      tableName();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

// where 부분 시작
  static final public void whereClause() throws ParseException {
    jj_consume_token(WHERE);
    booleanValueExpression();
  }

  static final public void booleanValueExpression() throws ParseException {
    booleanTerm();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      booleanTerm();
    }
  }

  static final public void booleanTerm() throws ParseException {
    booleanFactor();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      booleanFactor();
    }
  }

  static final public void booleanFactor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    booleanTest();
  }

  static final public void booleanTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
    case LEGAL_IDENTIFIER:
      predicate();
      break;
    case LEFT_PAREN:
      parenthesizedBooleanExpression();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void parenthesizedBooleanExpression() throws ParseException {
    jj_consume_token(LEFT_PAREN);
    booleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void predicate() throws ParseException {
    if (jj_2_2(4)) {
      comparisonPredicate();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEGAL_IDENTIFIER:
        nullPredicate();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

// ex > s_count >= 4
  static final public void comparisonPredicate() throws ParseException {
    compOperand();
    compOp();
    compOperand();
  }

  static final public void compOperand() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      comparableValue();
      break;
    case LEGAL_IDENTIFIER:
      if (jj_2_3(4)) {
        tableName();
        jj_consume_token(PERIOD);
      } else {
        ;
      }
      columnName();
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void compOp() throws ParseException {
    jj_consume_token(COMP_OPERATOR);
  }

  static final public void comparableValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      jj_consume_token(INT_VALUE);
      break;
    case CHAR_STRING:
      jj_consume_token(CHAR_STRING);
      break;
    case DATE_VALUE:
      jj_consume_token(DATE_VALUE);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void nullPredicate() throws ParseException {
    if (jj_2_4(4)) {
      tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    columnName();
    nullOperation();
  }

  static final public void nullOperation() throws ParseException {
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
      break;
    case NOT_NULL:
      jj_consume_token(NOT_NULL);
      break;
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(NULL);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// insert 쿼리 시작
  static final public void insertQuery() throws ParseException {
    jj_consume_token(INSERT_INTO);
    tableName();
    insertColumnsAndSource();
  }

  static final public void insertColumnsAndSource() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      columnNameList();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    valueList();
  }

// values (1, 'John', 3516-32-11)
  static final public void valueList() throws ParseException {
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    value();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      value();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void value() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      comparableValue();
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// delete from 쿼리 시작
  static final public void deleteQuery() throws ParseException {
    jj_consume_token(DELETE_FROM);
    tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereClause();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_10() {
    if (jj_3R_11()) return true;
    if (jj_scan_token(39)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) return true;
    }
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SimpleDBMSParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfe20,0xfe00,0xfe00,0x0,0x30000,0x8000000,0x30000,0x0,0x1c0,0x0,0x0,0x80000,0x200000,0x0,0x80000,0x400000,0x1000000,0x800000,0x80000000,0x0,0x0,0x0,0xc800000,0x80000000,0x0,0x4000000,0x200000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x2,0x4000,0x0,0x0,0x2,0x0,0x2,0x4020,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x4e00,0x4000,0x4e00,0xe00,0x0,0x0,0x2,0xe00,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[4];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMSParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[51];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 51; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
